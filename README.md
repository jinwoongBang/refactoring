# Refactoring

---

### 1. 리팩토링의 첫 단계

---

### 4. 테스트 코드 작성

---

### 6. 기본적인 리팩토링

#### 1) 함수 추출하기 : Extract Function

- 중복되는 함수의 추출

#### 2) 함수 인라인하기 : Inline Function

- 한 번만 사용되는 함수는 추출할 필요 없음
- 함수 추출하기 반대

#### 3) 변수 추출하기 : Extract Variable

- 함수 추출과 동일

#### 4) 변수 인라인하기 : Inline Variable

- 함수 인라인과 동일

#### 5) 함수 선언 바꾸기(함수 이름 바꾸기) : Change Function Declaration

- 이름만 봐도 무슨 역할인지 인지 할 수 있도록 작성
- 상위 객체를 포함하는 변수명 제거
- 이름이 생각나지 않을 땐 기능별로 주석을 달아보면 멋진 변수명이 생각날 수 있다

#### 6) 변수 캡슐화하기 : Encapsulate Variable

- 데이터를 변경하고 사용하는 코드를 감시 할수 있는 확실한 통로가 되어줌
- 때문에 변경 전, 후 검증이나 추가 로직을 쉽게 삽입 가능
- 데이터에 대한 결합도가 높아지는 것을 막는다.

#### 7) 변수 이름 바꾸기 : Rename Variable

- 변수명 앞에 타입을 붙여주는 것도 좋다

#### 8) 매개변수 객체 만들기 : Introduce Parameter Object

- VO(Value Object) 로 매개변수 전달하는 것
- 클래스(VO)로 만들어 두면 관련 동작들을 이 클래스로 옮길 수 있는 이점.

#### 9) 여러 함수를 클래스로 묶기 : Combine Functions into Class

- 공통된 데이터를 가지고 동작하는 함수들이 많을 경우 하나의 클래스로 묶으면 좋다.

#### 10) 여러 함수를 변환 함수로 묶기 : Combine Functions into Transform

- 6.9 여러 함수를 클래스로 묶기와 비슷하다.
- 중요한 차이는 원본 데이터가 코드 안에서 갱신될 때는 클래스로 묶는 편이 훨씬 낫다.
- 기존 데이터에 필요한 정보를 추가하여 return 해주는 것
- 불변성을 유지하기 위해 깊은 복사를 통해 원본 데이터에 영향을 주지않아야 한다

#### 11) 단계 쪼개기 : Split Phase

- 장황한 코드를 기능별로 쪼개는 것
- 명령줄 호출과 표준 출력에 쓰는 느리고 불편한 작업과 자주 테스트해야 할 복잡한 동작을 분리함으로써 테스트를 더 쉽게 수행하게 만들었다.
  (험블 객체 패턴)
- 여기서도 단계별 매개변수들을 클래스로 캡슐화 함으로써 여러 기능들을 클래스 안에서 처리

---

### 7. 캡슐화

- 캡슐화가 잘 되어 있다면 무언가를 변경해야 할 때 함께 고려해야할 모듈 수가 적어져서 코드를 변경하기 훨씬 쉬워진다.

#### 1) 레코드 캡슐화하기 : Encapsulate Record

- 모든 쓰기를 함수 안에서 처리한다 는 것이 핵심
- 내부 데이터를 복제해서 제공하는 것도 한 방법
- 자기 자신 또는 내부 데이터에 getter, setter 를 통해만 접근 할 수 있도록 변경

#### 2) 컬렉션 캡슐화하기 : Encapsulate Collection

- getter 가 컬렉션 자체를 반환하도록 한다면, 캡슐화의 의미가 없다.
  (원본 모듈 밖에서 컬렉션을 수정하지 않는 습관을 갖고 있따면 상관 없다.)
- add(), remove() 를 사용하여 컬렉션 객체의 데이터를 변경하도록 수정

#### 3) 기본형을 객체로 바꾸기 : Replace Primitive with Object

- 클래스(VO) 형태로 바꿔주는 것과 비슷하다.
- 예를 들어 어떤 VO 타입의 List 를 filter() 해야 한다면, 조건 로직을 VO 안에 넣어 코드를 간결하게 가져갈 수 있다.

#### 4) 임시 변수를 질의 함수로 바꾸기 : Replace Temp with Query

- 어떤 조건에 의해 변동되는 값을 가지는 임시 변수가 있다면, 클래스 내에서 조건문의 함수(질의 함수)로 변경.

#### 5) 클래스 추출하기 : Extract Class

- Person 내 비슷한 데이터들을 분류하여 클래스(VO) 로 추출하는 것
- 클래스는 반드시 명확하게 추상화하고 소수의 주어진 역할만 처리해야 함.
- 일부 데이터와 메서드를 따로 묶을 수 있다면 분리 하라는 신호.

#### 6) 클래스 인라인하기 : Inline Class

- '클래스 추출하기' 의 반대
- 리팩토링을 하고 난 후 특정 클래스에 남은 역할이 거의 없을 때 이런 현상이 자주 생긴다.
- 이럴 땐 가장 많이 사용하는 클래스로 흡수(인라인) 시켜버리자.

#### 7) 위임 숨기기 : Hide Delegate

```javascript
manager = aPerson.department.manager;

manager = aPerson.manager;
class Person {
  get manager() {
    return this.department.manager;
  }
}
```

#### 8) 중개자 제거하기 : Remove Middle Man

- '위임 숨기기' 의 반대
- 클라이언트가 위임 객체의 또 다른 기능을 사용하고 싶을 때마다 서버에 위임 메서드를 추가해야 하는데
- 단순히 전달만 하는 위임 메서드들이 있다면 과감히 중개자를 제거한다.

#### 9) 알고리즘 교체하기 : Substitute Algorithm

- javascript 내 제공하는 API 를 되도록 사용하자

---

### 8. 기능 이동

#### 1) 함수 옮기기 : Move Function
- 중첩 함수를 최상위로 옭기기
  - 임시 함수를 만들고 그 임시 함수를 원래 함수에서 호출하도록 한다.
  - 이상이 없다면 임시 함수의 이름을 원래 함수로 바꾸어 리팩토링 완료.
- 다른 클래스로 옮기기
  - 
#### 2) 필드 옮기기 : Move Field

#### 3) 문장을 함수로 옮기기 : Move Statements into Function

#### 4) 문장을 호출한 곳으로 : 옮기기 Move Statements to Callers

#### 5) 인라인 코드를 함수 호출로 바꾸기 : Replace Inline Code with Function Call

#### 6) 문장 슬라이드하기 : Slide Statements

#### 7) 반복문 쪼개기 : Split Loop

#### 8) 반복문을 파이프라인으로 바꾸기 : Replace Loop with Pipeline

#### 9) 죽은 코드 제거하기 : Remove Dead Code
